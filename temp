from collections import deque
from dataclasses import dataclass, field
from typing import Deque, List
from tabulate import tabulate
from core.TetrisBlock import TetrisBlock


@dataclass
class TetrisBoard:
    CHARACTER_FOR_EMPTY_CELL = "0"
    width: int
    """
     The reason we use default_factory for mutable objects, like lists, is to prevent unexpected behavior due to shared references. For instance, if you were to set data=[] directly as the default value, every instance of the dataclass would share the same list, which is rarely what you want. Using default_factory=list ensures each instance gets its own unique list.
    """
    board: Deque[List[str]] = field(default_factory=deque)

    def add_empty_row(self):
        self.board.appendleft([TetrisBoard.CHARACTER_FOR_EMPTY_CELL] * self.width)

    def add_empty_rows(self, rows_count: int):
        [self.add_empty_row() for _ in range(rows_count)]


    # Mark this as private
    def add_row(self, row: List[str]):
        if len(row) != self.width:
            raise ValueError(
                f"Row must have the same width of the board ({self.width})"
            )
        self.board.append(row)

    def get_board_height(self):
        return len(self.board)
    
    def set_cell(self, row_idx: int, column_idx: int, value):
        self.board[row_idx][column_idx] = value
    
    def is_cell_empty(self, row_idx: int, column_idx: int) -> bool:
        try:
            return self.board[row_idx][column_idx] == TetrisBoard.CHARACTER_FOR_EMPTY_CELL
        except IndexError:
            return False
  
    def get_first_empty_row_from_bottom_to_top(self, column_idx: int) -> int | None:
        board_height = self.get_board_height()
        for row_index in range(board_height - 1, -1, -1): # Iterate it backwards
            if self.board[row_index][column_idx] == TetrisBoard.CHARACTER_FOR_EMPTY_CELL:
                return row_index


    def copy_matrix(self, block: TetrisBlock, start_row, start_col):
        # Iterate over each row and column of the source matrix
        for row in range(block.get_height()):
            for col in range(block.get_width()):
                # Calculate the position in the target matrix
                target_row = start_row + row
                target_col = start_col + col
                
                # Ensure we're not going out of bounds in the target matrix
                if 0 <= target_row < len(self.board) and 0 <= target_col < len(self.board[0]):
                    self.board[target_row][target_col] = block.get_value_at(row, col)

    def are_cells_clear(self, row_a, row_b, col):
        
        column_values = [row[col] for row in self.board[row_a: row_b]]
        # all(
        #     self.is_cell_empty(row, col)
        #     for row in range(row_b, row_a)
        # )

        

    def drop_block_at_column(self, block: TetrisBlock, col_idx: int):
        print(f'>>>>>>>>>>>> BLOCK at {col_idx} >>>>>>')
        print(block)
        if col_idx > self.width:
            print('EXCEPTION')
            raise ValueError(
                f"Column index must be less than the board's width  ({self.width})"
            )
        block_height = block.get_height()
        block_width = block.get_width()
        if len(self.board) == 0:
             self.add_empty_rows(block_height)
             self.copy_matrix(block, 0, col_idx)

        #column_values = [row[col_idx] for row in self.board[row_a: row_b]]


      

        for block_col_idx in range(block_width):
            column = block.get_column(block_col_idx)
            # First column of board
            column_board_array = [row[col_idx + block_col_idx] for row in self.board]
            for item in column_board_array[::-1]:
                if item != TetrisBoard.CHARACTER_FOR_EMPTY_CELL:

             





        #first_empty_row_idx_from_bottom_to_top = self.get_first_empty_row_from_bottom_to_top(col_idx)

        #column_values = [row[col_idx] for row in self.board]
        
        #print('>>')
        #print(column_values)
        #print('iii')
        #print(column_values[0:first_empty_row_idx_from_bottom_to_top + 1])
        # all(
        #     self.is_cell_empty(row, col)
        #     for row in range(row_b, row_a)
        # )
        #print(f'first_empty_cell_idx_from_bottom_to_top {first_empty_row_idx_from_bottom_to_top}')
        #candidate_row = first_empty_row_idx_from_bottom_to_top 
        #positioned = False
        # from first_empty_row_idx_from_bottom_to_top to  first_empty_row_idx_from_bottom_to_top - block_height
        # from col_idx to col_idx + block_width
         
        # for block_col in range(block_width):
        #     #counsecutive_blocks = block.count_consecutive_non_empty_from_bottom(block_col)
        #     self.board[candidate_row][block_col + col_idx]
        #     for row_index in range(block_height - 1, -1, -1): # Iterate it backwards
        #         if self.board[candidate_row][col_idx] == TetrisBoard.CHARACTER_FOR_EMPTY_CELL:
        #             return row_index

            #print(f'mmmm counsecutive_blocks {counsecutive_blocks} for col: {block_col}')
        # while positioned is False:
        #     for block_col in range(block_width):
        #         counsecutive_blocks = block.count_consecutive_non_empty_from_bottom(block_col)
        #         print(f'mmmm counsecutive_blocks {counsecutive_blocks} for col: {block_col}')

        # first_empty_cell_idx_from_bottom_to_top = self.get_first_empty_cell_from_bottom_to_top(column_idx)
        
        # print(f'first_empty_cell_idx_from_bottom_to_top at {column_idx} column is: {first_empty_cell_idx_from_bottom_to_top}')

        # new_block_height = block.get_height()
        # if first_empty_cell_idx_from_bottom_to_top is None:
        #     print(f'Adding empty {new_block_height} rows')            
        #     self.add_empty_rows(new_block_height)
        #     first_empty_cell_idx_from_bottom_to_top = new_block_height - 1

      
        # all_columns_empty = True

        # # For each column of the block
        # for block_column_idx in range(block.get_width()):
        #     # Count from bottom to top how many non empty spaces are
        #     spaces_needed = block.count_consecutive_non_empty_from_bottom(block_column_idx)
        #     print(f" spaces_needed {column_idx} -->  {spaces_needed} ")

        #     are_all_cells_empty = all(
        #         self.is_cell_empty(row, column_idx)
        #         for row in range(
        #             first_empty_cell_idx_from_bottom_to_top,
        #             first_empty_cell_idx_from_bottom_to_top - (spaces_needed - 1)# from 2 to 1 in the example of L
        #         )
        #     )

        #     if not are_all_cells_empty:
        #         all_columns_empty = False
        #         break

        # if all_columns_empty:
        #     # copy block to board
        #     for block_row in range(block.get_height()):
        #         for block_col in range(block.get_width()):
        #             # Fetch the value from the block
        #             value = block.get_value_at(block_row, block_col)

        #             # Calculate the corresponding row on the Tetris board
        #             board_row = first_empty_cell_idx_from_bottom_to_top - block_row
            
                   
        #             self.set_cell(board_row, block_col, value)

                
        #     # for row in range(
        #     #     first_row_with_empty_space_at_column_index,
        #     #     first_row_with_empty_space_at_column_index + new_block_height
        #     # ):
        #     #     print(row)        
        print('>>>>>>>>>>>> BOARD >>>>>>')
        print(self)
        # self.check_for_filled_rows()
        
        
    def check_for_filled_rows(self):
        return

    def __str__(self):
        # for row_idx, row in enumerate(self.board):
        #     for cell_idx, cell in enumerate(row):
        #         print(f"Row {row_idx}, Column {cell_idx}: {cell}")
        return tabulate(self.board, tablefmt="grid")
